(function() {
  var PLUGIN_NAME, cleanSketch, fs, gutil, path, recursive, rimraf, spawn, temporary, through, yesOrNo;

  spawn = require('child_process').spawn;

  through = require('through2');

  fs = require('fs');

  path = require('path');

  gutil = require('gulp-util');

  temporary = require('temporary');

  cleanSketch = require('clean-sketch');

  recursive = require('recursive-readdir');

  rimraf = require('rimraf');

  PLUGIN_NAME = 'gulp-sketch';

  yesOrNo = function(val) {
    return val === true || val === 'Yes' || val === 'yes' || val === 'YES';
  };

  module.exports = function(options) {
    var args, cmnd;
    if (options == null) {
      options = {};
    }
    cmnd = 'sketchtool';
    args = [];
    if (options["export"]) {
      args.push('export');
      args.push(options["export"]);
    }
    if (options.trimmed) {
      args.push('--trimmed=' + options.trimmed);
    }
    if (options.compression) {
      args.push('--compression=' + options.compression);
    }
    if (options.scales) {
      args.push('--scales=' + options.scales);
    }
    if (options.formats) {
      args.push('--formats=' + options.formats);
    }
    if (options.item) {
      args.push('--item=' + options.item);
    }
    if (yesOrNo(options.progressive)) {
      args.push('--progressive');
    }
    if (yesOrNo(options.compact)) {
      args.push('--compact');
    }
    if (options.background) {
      args.push('--background=' + options.background);
    }
    if (yesOrNo(options.groupContentsOnly)) {
      args.push('--group-contents-only');
    }
    if (options.items) {
      args.push('--items=' + options.items);
    }
    if (yesOrNo(options.saveForWeb)) {
      args.push('--save-for-web');
    }
    if (options.bounds) {
      args.push('--bounds=' + options.bounds);
    }
    options.clean = yesOrNo(options.clean);
    return through.obj(function(file, encoding, callback) {
      var program, src, tmp_dir;
      if (file.isStream()) {
        this.emit('error', new gutil.PluginError(PLUGIN_NAME, 'Streaming not supported'));
        return callback();
      }
      src = file.path;
      tmp_dir = new temporary.Dir();
      if (options.outputJSON) {
        args.push('--outputJSON=' + tmp_dir.path + '/' + options.outputJSON);
      }
      program = spawn(cmnd, args.concat(src, '--output=' + tmp_dir.path));
      if (options.verbose) {
        program.stdout.on('data', function(data) {
          return gutil.log(data.toString());
        });
      }
      return program.stdout.on('end', (function(_this) {
        return function() {
          return recursive(tmp_dir.path, function(err, files) {
            var abs_path, b, f, i, len, rel_path;
            for (i = 0, len = files.length; i < len; i++) {
              abs_path = files[i];
              rel_path = path.relative(tmp_dir.path, abs_path);
              f = new gutil.File({
                cwd: file.cwd,
                base: file.base,
                path: path.join(file.base, rel_path)
              });
              b = fs.readFileSync(abs_path);
              if (options.clean && /\.svg$/.test(rel_path)) {
                b = new Buffer(cleanSketch(b.toString()));
              }
              f.contents = b;
              _this.push(f);
            }
            return rimraf(tmp_dir.path, function() {
              return callback();
            });
          });
        };
      })(this));
    });
  };

}).call(this);
